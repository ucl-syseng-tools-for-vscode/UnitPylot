/**
 * Represents a coverage report for a single file
 */
export type FileCoverage = {
    filename: string;
    lines: {
        covered: number[];
        skipped: number[];
        missed: number[];
        branches_covered: number[][];
        branches_missed: number[][];
    };
    summary: {
        covered: number;
        skipped: number;
        missed: number;
        branches_covered: number;
        branches_missed: number;
        percentCovered: number;
        total: number;
    };
};

/**
 * Represents a coverage report
 */
export type Coverage = {
    files: FileCoverage[];
    totals: {
        covered: number;
        skipped: number;
        missed: number;
        total: number;
        percentCovered: number;
        branches_covered: number;
        branches_missed: number;
        branches_total: number;
    };
};

/**
 * Represents a raw coverage report generated by pytest-cov
 */
export type FileCoverageRaw = {
    excluded_lines: [number];
    executed_lines: [number];
    missing_lines: [number];
    executed_branches: number[][];
    missing_branches: number[][];
    summary: {
        covered_lines: number;
        excluded_lines: number;
        missing_lines: number;
        branches_covered: number;
        branches_missed: number;
        percent_covered: number;
        num_statements: number;
    };
}

/**
 * Merges two coverage reports together
 * @param existingCoverage The existing coverage report
 * @param newCoverage The new coverage report to merge
 * @returns The merged coverage report
 */

export function mergeCoverage(existingCoverage: Coverage, newCoverage: Coverage): Coverage {
    const outputFileCoverage: FileCoverage[] = [];
    const mergedCoverageMap: { [key: string]: FileCoverage } = {};

    // Add existing coverage to the map
    for (const existingFileCoverage of existingCoverage.files) {
        mergedCoverageMap[existingFileCoverage.filename] = existingFileCoverage;

        // Add existing file to output if not in new coverage
        if (!newCoverage.files.find(newFileCoverage => newFileCoverage.filename === existingFileCoverage.filename)) {
            outputFileCoverage.push(existingFileCoverage);
        }
    }

    // Loop through each new file coverage
    for (const newFileCoverage of newCoverage.files) {
        if (!mergedCoverageMap[newFileCoverage.filename]) {
            // Add new file
            outputFileCoverage.push(newFileCoverage);
            continue;
        }

        // Update the existing file coverage
        const existingCoverage = mergedCoverageMap[newFileCoverage.filename];

        // Union for covered
        const linesCoveredSet = new Set(existingCoverage.lines.covered.concat(newFileCoverage.lines.covered));
        const linesCovered = Array.from(linesCoveredSet);

        // Intersection for missed
        const linesMissedSet = intersectSets(new Set(existingCoverage.lines.missed), new Set(newFileCoverage.lines.missed));
        const linesMissed = Array.from(linesMissedSet);

        // Intersection for skipped
        const linesSkippedSet = intersectSets(new Set(existingCoverage.lines.skipped), new Set(newFileCoverage.lines.skipped));
        const linesSkipped = Array.from(linesSkippedSet);

        // Union for branches covered
        // Since 2d array, just concat and remove duplicates
        let branchesCovered = existingCoverage.lines.branches_covered.concat(newFileCoverage.lines.branches_covered);
        branchesCovered = removeDuplicates(branchesCovered);

        // Intersection for branches missed
        const branchesMissed = intersect2DArrays(existingCoverage.lines.branches_missed, newFileCoverage.lines.branches_missed);

        // Calculate new file totals and add
        const totalLines = linesCovered.length + linesSkipped.length + linesMissed.length;

        outputFileCoverage.push({
            filename: existingCoverage.filename,
            lines: {
                covered: linesCovered,
                skipped: linesSkipped,
                missed: linesMissed,
                branches_covered: branchesCovered,
                branches_missed: branchesMissed,
            },
            summary: {
                covered: linesCovered.length,
                skipped: linesSkipped.length,
                missed: linesMissed.length,
                branches_covered: branchesCovered.length,
                branches_missed: branchesMissed.length,
                percentCovered: (linesCovered.length / totalLines * 100) || 100,
                total: totalLines
            }
        });
    }

    // Calculate new overall totals
    let totalLines = 0;
    let linesCovered = 0;
    let linesSkipped = 0;
    let linesMissed = 0;
    let branchesCovered = 0;
    let branchesMissed = 0;
    let branchesTotal = 0;

    for (const fileCoverage of outputFileCoverage) {
        totalLines += fileCoverage.summary.total || 0;
        linesCovered += fileCoverage.summary.covered || 0;
        linesSkipped += fileCoverage.summary.skipped || 0;
        linesMissed += fileCoverage.summary.missed || 0;
        branchesCovered += fileCoverage.summary.branches_covered || 0;
        branchesMissed += fileCoverage.summary.branches_missed || 0;
        branchesTotal += (fileCoverage.summary.branches_covered + fileCoverage.summary.branches_missed) || 0;
    }

    return {
        files: outputFileCoverage,
        totals: {
            covered: linesCovered,
            skipped: linesSkipped,
            missed: linesMissed,
            total: totalLines,
            percentCovered: (linesCovered / totalLines * 100) || 100,
            branches_covered: branchesCovered,
            branches_missed: branchesMissed,
            branches_total: branchesTotal
        }
    };
}

function intersectSets<T>(setA: Set<T>, setB: Set<T>): Set<T> {
    let intersection = new Set<T>();
    for (let elem of setB) {
        if (setA.has(elem)) {
            intersection.add(elem);
        }
    }
    return intersection;
}

function removeDuplicates(arr: number[][]): number[][] {
    const seen = new Set<string>(); // Use a Set to store unique string representations of subarrays
    return arr.filter(subArr => {
        const key = JSON.stringify(subArr); // Convert subarray to string for comparison
        if (seen.has(key)) return false; // If already seen, skip it
        seen.add(key); // Otherwise, mark as seen and keep it
        return true;
    });
}

function intersect2DArrays(arr1: number[][], arr2: number[][]): number[][] {
    const set1 = new Set(arr1.map(subArr => JSON.stringify(subArr))); // Convert to Set for quick lookup
    return arr2.filter(subArr => set1.has(JSON.stringify(subArr))); // Keep only common subarrays
}
