
/* 
    * This file contains functions related to parsing the pytest json output.
    * The TestRunner class still manages what tests are run.
*/

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as sqlite3 from 'sqlite3';
import { readJsonFile } from "./helper-functions";
import { TestFunctionResult, TestResult, MemoryAllocation } from "./results";

export const PYTEST_OUTPUT_FILE = '.pytest_results.json';
export const PYTEST_MONITOR_OUTPUT_FILE = '.pytest_resource_usage.sqlite';

type PytestOutput = {
    tests: PytestTest[];
}

type PytestTest = {
    nodeid: string;
    lineno: number;
    outcome: string;
    setup: PytestOutcome;
    call: PytestOutcome;
    teardown: PytestOutcome;
}

type PytestOutcome = {
    duration: number;
    outcome: string;
    longrepr?: string;
}

type PytestResourceDbData = {
    ITEM: string;
    ITEM_FS_LOC: string;
    ITEM_VARIANT: string;
    CPU_USAGE: number;
    MEM_USAGE: number;
}

/**
 * Query the sqlite3 database for memory/cpu data.
 * DB is generated by the pytest-monitor package.
 * 
 * @param pytestResult 
 */

async function getResourceData(dbPath: string, pytestResult: TestResult): Promise<TestResult> {
    return new Promise((resolve, reject) => {
        const db = new sqlite3.Database(dbPath, (err) => {
            if (err) {
                console.error('Error opening database:', err.message);
                reject(err);
                return;
            }
            console.log('Connected to SQLite database.');
        });

        // Get most recent test data
        const stmt = `
            SELECT ITEM_FS_LOC, ITEM, ITEM_VARIANT, CPU_USAGE, MEM_USAGE
            FROM TEST_METRICS
            WHERE SESSION_H == (
                SELECT SESSION_H FROM TEST_SESSIONS
                ORDER BY RUN_DATE DESC LIMIT 1
            );
        `;

        db.all(stmt, [], (err, rows: PytestResourceDbData[]) => {
            if (err) {
                console.error('Error running query:', err.message);
                reject(err);
                return;
            }

            rows.forEach((row) => {
                const filePath = row.ITEM_FS_LOC;
                const testName = row.ITEM_VARIANT;
                const cpuUsage = row.CPU_USAGE;
                const memUsage = row.MEM_USAGE;

                // Only save the data if the test is in the pytestResult
                if (!pytestResult[filePath]) {
                    return;
                }

                // We need to loop through every test in the file because the test class name is not included in the db
                for (const test in pytestResult[filePath]) {
                    if (test.includes(testName) && !pytestResult[filePath][test].totalMemory) {
                        pytestResult[filePath][test].cpuUsage = cpuUsage;
                        pytestResult[filePath][test].totalMemory = memUsage;
                        break;
                    }
                }
            });

            // Close the database and resolve the promise
            db.close((err) => {
                if (err) {
                    console.error('Error closing database:', err.message);
                    reject(err);
                    return;
                }
                console.log('Closed the database connection.');
                resolve(pytestResult);
            });
        });
    });
}


/**
 * Get the pytest results from the output files.
 * 
 * @returns TestResult
 */
export async function getPytestResult(): Promise<TestResult> {
    // Get cwd
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
        throw new Error('No workspace folder found');
    }
    const workspacePath = workspaceFolders[0].uri.fsPath;

    // Read the pytest output file
    const jsonFilePath = path.join(workspacePath, PYTEST_OUTPUT_FILE);
    const pytestOutput = readJsonFile(jsonFilePath) as PytestOutput;

    // Parse the output
    let pytestResult: TestResult = {};

    for (const test of pytestOutput.tests) {
        const fullName = test.nodeid;
        const filePath = fullName.split('::')[0];
        const testName = fullName.split('::').slice(1).join('::');

        const testResultObj: TestFunctionResult = {
            passed: test.outcome === 'passed',
            time: test.call.duration,
            errorMessage: test.call.longrepr,
            lineNo: test.lineno.toString(),
            filePath: filePath,
            testName: testName
        };

        if (!pytestResult[filePath]) {
            pytestResult[filePath] = {};
        }
        pytestResult[filePath][testName] = testResultObj;
    }

    // Parse the resource db
    const dbPath = path.join(workspacePath, PYTEST_MONITOR_OUTPUT_FILE);
    pytestResult = await getResourceData(dbPath, pytestResult);

    // Delete the pytest output files
    try {
        fs.unlinkSync(jsonFilePath);
    }
    catch (err) {
        console.error(err);
    }
    try {
        fs.unlinkSync(dbPath);
    }
    catch (err) {
        console.error(err);
    }

    return pytestResult;
}